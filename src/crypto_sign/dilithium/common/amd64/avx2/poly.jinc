require "../params.jinc"
require "../montgomery.jinc" // TODO: Erase this dependency

fn poly_add(reg ptr u32[Li2_polydeg] f g result)
	-> reg ptr u32[Li2_polydeg]
{
	reg u256 v256;
	reg u64 offset;

	?{}, offset = #set0_64();
	while (offset < 4 * Li2_polydeg) {
		v256 = #VMOVDQA_256(f.[u256 (int) offset]);
		v256 = #VPADD_8u32(v256, g.[u256 (int) offset]);
		#VMOVDQA_256(result.[u256 (int) offset]) = v256;

		offset += 32;
	}
	return result;
}

fn poly_subtract(reg ptr u32[Li2_polydeg] f g result)
	-> reg ptr u32[Li2_polydeg]
{
	// TODO: [electricdusk] refactor: Rename to poly_sub

	reg u256 v256;
	reg u64 offset;

	?{}, offset = #set0_64();
	while (offset < 4 * Li2_polydeg) {
		v256 = #VMOVDQA_256(f.[u256 (int) offset]);
		v256 = #VPSUB_8u32(v256, g.[u256 (int) offset]);
		#VMOVDQA_256(result.[u256 (int) offset]) = v256;

		offset += 32;
	}
	return result;
}

fn poly_accumulate(reg ptr u32[Li2_polydeg] f acc)
	-> reg ptr u32[Li2_polydeg]
{
	reg u256 v256;
	reg u64 offset;

	?{}, offset = #set0_64();
	while (offset < 4 * Li2_polydeg) {
		v256 = #VMOVDQA_256(acc.[u256 (int) offset]);
		v256 = #VPADD_8u32(v256, f.[u256 (int) offset]);
		#VMOVDQA_256(acc.[u256 (int) offset]) = v256;

		offset += 32;
	}
	return acc;
}

fn poly_reduce32(reg ptr u32[Li2_polydeg] poly)
	-> reg ptr u32[Li2_polydeg]
{
	// TODO [electricdusk] Vectorize this function
	
	reg u64 i;
	reg u32 val res;

	?{}, i = #set0_64();
	while(i < Li2_polydeg) {
		val = poly[(int) i];
		res = reduce32(val);
		poly[(int) i] = res;
		i += 1;
	}

	return poly;
}


u256[1] poly_pointwise_qinv = {
	(8u32) [58728449, 58728449, 58728449, 58728449, 58728449, 58728449, 58728449, 58728449]
};
u256[1] poly_pointwise_q = {
	(8u32) [8380417, 8380417, 8380417, 8380417, 8380417, 8380417, 8380417, 8380417]
};

fn poly_pointwise_montgomery(reg ptr u32[Li2_polydeg] fft_f fft_g fft_prod)
	-> reg ptr u32[Li2_polydeg]
{
	// TODO: [electricdusk] This loop can be unrolled more to do 3 chunks
	// in parallel each time.
	// TODO: [electricdusk] Have the caller provide qinv and q.

	reg u256 qinv q;
	reg u256 f_lo f_hi;
	reg u256 g_lo g_hi;
	reg u256 prod_lo prod_hi;
	reg u256 t_lo t_hi;

	reg u64 offset;

	qinv = #VMOVDQA_256(poly_pointwise_qinv[0]);
	q = #VMOVDQA_256(poly_pointwise_q[0]);

	?{}, offset = #set0_64();
	while (offset < 4 * Li2_polydeg) {
		f_lo = #VMOVDQA_256(fft_f.[u256 (int) offset]);
		g_lo = #VMOVDQA_256(fft_g.[u256 (int) offset]);
		f_hi = #VMOVSHDUP_4u64(f_lo);
		g_hi = #VMOVSHDUP_4u64(g_lo);

		// Multiply
		prod_lo = #VPMUL_256(f_lo, g_lo);
		prod_hi = #VPMUL_256(f_hi, g_hi);

		// Reduce
		t_lo = #VPMUL_256(prod_lo, qinv);
		t_hi = #VPMUL_256(prod_hi, qinv);
		t_lo = #VPMUL_256(t_lo, q);
		t_hi = #VPMUL_256(t_hi, q);
		prod_lo = #VPSUB_4u64(prod_lo, t_lo);
		prod_hi = #VPSUB_4u64(prod_hi, t_hi);

		prod_lo = #VMOVSHDUP_4u64(prod_lo);
		prod_lo = #VPBLEND_8u32(prod_lo, prod_hi, 0xAA);
		#VMOVDQA_256(fft_prod.[u256 (int) offset]) = prod_lo;

		offset += 32;
	}
	return fft_prod;
}

fn zero_poly(reg ptr u32[Li2_polydeg] f)
	-> reg ptr u32[Li2_polydeg]
{
	reg u256 zero;
	reg u64 offset;

	?{}, zero = #set0_256();
	?{}, offset = #set0_64();

	while(offset < 4 * Li2_polydeg) {
		#VMOVDQA_256(f.[u256 (int) offset]) = zero;
		offset += 32;
	}
	return f;
}

fn poly_caddq(reg ptr u32[Li2_polydeg] f)
	-> reg ptr u32[Li2_polydeg]
{
	// TODO [electricdusk] Vectorize this function
	
	reg u64 i;
	reg u32 val;
	?{}, i = #set0_64();
	while(i < Li2_polydeg) {
		val = f[(int) i];
		val = caddq(val);
		f[(int) i] = val;
		i += 1;
	}
	return f;
}

inline
fn poly_checknorm(reg ptr u32[Li2_polydeg] f, inline int threshold)
	-> stack u8
{
	stack u8 r;
	reg u8 result;
	stack u8 result_s;
	reg u8 c;
	reg u64 i;
	reg u32 val;

	result = 0;

	?{}, i = #set0_64();
	while(i < Li2_polydeg) {
		val = f[(int) i];
		r = checknorm(val, threshold);
		c = r;
		result |= c;
		i += 1;
	}

	result_s = result;
	return result_s;
}